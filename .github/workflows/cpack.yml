name: CPack Integration Testing

on:
  push:
    branches: [ "integration", "master", "CPack-integration" ]
  pull_request:
    branches: [ "integration", "master" ]
  workflow_dispatch:

jobs:
  cpack-basic:
    name: CPack Basic Integration Test
    runs-on: ${{ matrix.os }}
    
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        build_type: [Release]
        include:
          - os: windows-latest
            c_compiler: cl
            cpp_compiler: cl
            expected_generators: "TGZ;ZIP"
            expected_packages: ["MyLibrary-*.tar.gz", "MyLibrary-*.zip"]
          - os: ubuntu-latest 
            c_compiler: gcc
            cpp_compiler: g++
            expected_generators: "TGZ;DEB;RPM"
            expected_packages: ["MyLibrary-*.tar.gz", "mylibrary-*.deb", "mylibrary-*.rpm"]
          - os: macos-latest
            c_compiler: clang
            cpp_compiler: clang++
            expected_generators: "TGZ;DragNDrop"
            expected_packages: ["MyLibrary-*.tar.gz", "MyLibrary-*.dmg"]

    steps:
    - uses: actions/checkout@v4

    - name: Setup MSVC Developer Command Prompt
      if: runner.os == 'Windows'
      uses: ilammy/msvc-dev-cmd@v1

    - name: Install Linux packaging tools
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y rpm dpkg-dev gnupg2

    # GPG Setup for Package Signing
    - name: Install GPG on macOS
      if: runner.os == 'macOS'
      run: |
        brew install gnupg

    - name: Install GPG on Windows
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        # Windows runners often have GPG pre-installed, check first
        $gpgPath = Get-Command gpg -ErrorAction SilentlyContinue
        if ($gpgPath) {
          Write-Host "GPG already installed at: $($gpgPath.Path)"
          gpg --version
        } else {
          Write-Host "Installing GPG via direct download..."
          
          # Download GPG directly instead of using Chocolatey (which times out)
          $gpgUrl = "https://www.gnupg.org/ftp/gcrypt/binary/gnupg-w32-2.4.5_20240307.exe"
          $installerPath = "$env:TEMP\gnupg-installer.exe"
          
          Write-Host "Downloading GPG installer..."
          Invoke-WebRequest -Uri $gpgUrl -OutFile $installerPath
          
          Write-Host "Installing GPG silently..."
          Start-Process -FilePath $installerPath -ArgumentList "/S" -Wait -NoNewWindow
          
          # Add GPG to PATH
          $gpgInstallPath = "C:\Program Files (x86)\GnuPG\bin"
          if (Test-Path $gpgInstallPath) {
            echo "$gpgInstallPath" >> $env:GITHUB_PATH
            $env:PATH = "$gpgInstallPath;$env:PATH"
            Write-Host "GPG installed and added to PATH"
          } else {
            # Fallback: Try the Git for Windows GPG
            $gitGpgPath = "C:\Program Files\Git\usr\bin"
            if (Test-Path "$gitGpgPath\gpg.exe") {
              echo "$gitGpgPath" >> $env:GITHUB_PATH
              $env:PATH = "$gitGpgPath;$env:PATH"
              Write-Host "Using Git for Windows GPG"
            } else {
              Write-Host "Warning: GPG installation path not found"
            }
          }
        }

    - name: Verify GPG Installation
      shell: bash
      run: |
        echo "=== Verifying GPG installation ==="
        
        # For Windows, also check common locations if 'which' fails
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          # Try multiple possible GPG locations on Windows
          if command -v gpg &> /dev/null; then
            echo "✅ GPG found via command"
            gpg --version | head -3
          elif [ -f "/c/Program Files (x86)/GnuPG/bin/gpg.exe" ]; then
            echo "✅ GPG found at Program Files"
            "/c/Program Files (x86)/GnuPG/bin/gpg.exe" --version | head -3
            # Add to PATH for this session
            export PATH="/c/Program Files (x86)/GnuPG/bin:$PATH"
          elif [ -f "/c/Program Files/Git/usr/bin/gpg.exe" ]; then
            echo "✅ GPG found at Git installation"
            "/c/Program Files/Git/usr/bin/gpg.exe" --version | head -3
            # Add to PATH for this session
            export PATH="/c/Program Files/Git/usr/bin:$PATH"
          else
            echo "❌ GPG not found in common locations"
            echo "Searching for gpg.exe..."
            find /c -name "gpg.exe" 2>/dev/null | head -5
            exit 1
          fi
        else
          # Linux and macOS
          which gpg || which gpg2 || (echo "❌ GPG not found in PATH" && exit 1)
          gpg --version | head -3
        fi
        
        echo "✅ GPG installation verified"

    - name: Generate Test GPG Key
      shell: bash
      run: |
        echo "=== Generating test GPG key for CI ==="
        
        # Create key generation batch file
        cat > key-gen-batch << 'EOF'
        Key-Type: RSA
        Key-Length: 2048
        Subkey-Type: RSA
        Subkey-Length: 2048
        Name-Real: CI Test User
        Name-Email: ci-test@target-install-package.local
        Expire-Date: 0
        %no-protection
        %commit
        EOF
        
        # Generate key
        gpg --batch --generate-key key-gen-batch
        
        # Verify key was created
        gpg --list-keys ci-test@target-install-package.local
        
        # Set environment variable for subsequent steps
        echo "GPG_SIGNING_KEY=ci-test@target-install-package.local" >> $GITHUB_ENV
        
        echo "✅ Test GPG key generated successfully"

    - name: Enable GPG Signing in CPack Basic Example
      shell: bash
      run: |
        echo "=== Enabling GPG signing in cpack-basic example ==="
        cd examples/cpack-basic
        
        # Backup original CMakeLists.txt
        cp CMakeLists.txt CMakeLists.txt.backup
        
        # Create a temporary file with the modified content
        # This approach works on both GNU and BSD sed
        awk '
        /^export_cpack\(/ { in_export=1 }
        in_export && /^)$/ {
          print "  GPG_SIGNING_KEY \"$ENV{GPG_SIGNING_KEY}\""
          print "  GENERATE_CHECKSUMS ON"
        }
        { print }
        in_export && /^)$/ { in_export=0 }
        ' CMakeLists.txt > CMakeLists.txt.tmp
        
        # Replace the original file
        mv CMakeLists.txt.tmp CMakeLists.txt
        
        echo "=== Modified export_cpack call ==="
        # Show the modified export_cpack section
        sed -n '/export_cpack(/,/^)/p' CMakeLists.txt
        
        echo "✅ GPG signing enabled in example"

    - name: Configure CPack Basic Example
      shell: bash
      run: |
        cd examples/cpack-basic
        mkdir build && cd build
        
        cmake .. \
          -DCMAKE_CXX_COMPILER=${{ matrix.cpp_compiler }} \
          -DCMAKE_C_COMPILER=${{ matrix.c_compiler }} \
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
          -DCMAKE_INSTALL_PREFIX=./install \
          -DPROJECT_LOG_COLORS=OFF

    - name: Build CPack Basic Example
      shell: bash
      run: |
        cd examples/cpack-basic/build
        cmake --build . --config ${{ matrix.build_type }}

    - name: Test Installation
      shell: bash
      run: |
        cd examples/cpack-basic/build
        
        echo "=== Testing component-based installation ==="
        
        # Install all components
        cmake --install . --config ${{ matrix.build_type }}
        
        # Verify installation structure
        echo "=== Installation structure ==="
        find install/ -type f | sort
        
        # Test component-specific installations
        echo "=== Testing Runtime component ==="
        cmake --install . --config ${{ matrix.build_type }} --component Runtime --prefix ./runtime-only
        find runtime-only/ -type f | sort
        
        echo "=== Testing Development component ==="
        cmake --install . --config ${{ matrix.build_type }} --component Development --prefix ./dev-only
        find dev-only/ -type f | sort
        
        echo "=== Testing Tools component ==="
        cmake --install . --config ${{ matrix.build_type }} --component Tools --prefix ./tools-only
        find tools-only/ -type f | sort

    - name: Generate CPack Packages with GPG Signing
      shell: bash
      env:
        GPG_SIGNING_KEY: ci-test@target-install-package.local
      run: |
        cd examples/cpack-basic/build
        
        echo "=== Generating packages with CPack and GPG signing ==="
        echo "GPG_SIGNING_KEY: $GPG_SIGNING_KEY"
        
        # Verify GPG key is available
        gpg --list-keys "$GPG_SIGNING_KEY" || (echo "❌ GPG key not found" && exit 1)
        
        # Generate packages with signing
        cpack --verbose
        
        echo "=== Generated packages ==="
        ls -la *.tar.gz *.zip *.deb *.rpm *.dmg 2>/dev/null || echo "Some package types not generated (expected on this platform)"
        
        echo "=== Generated signatures and checksums ==="
        ls -la *.sig *.sha256 *.sha512 2>/dev/null || echo "No signatures or checksums found"
        
        echo "=== Generated verification script ==="
        ls -la verify.sh 2>/dev/null || echo "No verification script found"

    - name: Verify Package Contents
      shell: bash
      run: |
        cd examples/cpack-basic/build
        
        echo "=== Verifying package contents ==="
        
        # Find and verify TGZ packages (available on all platforms)
        if ls MyLibrary-*-Runtime.tar.gz 1> /dev/null 2>&1; then
          echo "=== Runtime package contents ==="
          (tar -tzf MyLibrary-*-Runtime.tar.gz | head -10) 2>/dev/null || [ $? -eq 141 ] || true
          
          echo "=== Development package contents ==="
          (tar -tzf MyLibrary-*-Development.tar.gz | head -10) 2>/dev/null || [ $? -eq 141 ] || true
          
          echo "=== Tools package contents ==="
          (tar -tzf MyLibrary-*-TOOLS.tar.gz | head -10) 2>/dev/null || [ $? -eq 141 ] || true
          
          # Verify component separation
          runtime_has_exe=$(tar -tzf MyLibrary-*-Runtime.tar.gz | grep -c "bin/mytool" || true)
          dev_has_headers=$(tar -tzf MyLibrary-*-Development.tar.gz | grep -c "include/" || true)
          tools_has_exe=$(tar -tzf MyLibrary-*-TOOLS.tar.gz | grep -c "bin/mytool" || true)
          
          echo "Runtime package has executable: $runtime_has_exe (should be 0)"
          echo "Development package has headers: $dev_has_headers (should be > 0)"
          echo "Tools package has executable: $tools_has_exe (should be > 0)"
          
          if [[ "$runtime_has_exe" != "0" ]]; then
            echo "❌ Runtime package incorrectly contains executable"
            exit 1
          fi
          
          if [[ "$dev_has_headers" == "0" ]]; then
            echo "❌ Development package missing headers"
            exit 1
          fi
          
          if [[ "$tools_has_exe" == "0" ]]; then
            echo "❌ Tools package missing executable"
            exit 1
          fi
          
          echo "✅ Component separation verified"
        else
          echo "❌ Component packages not generated"
          exit 1
        fi

    - name: Verify GPG Signatures and Checksums
      shell: bash
      run: |
        cd examples/cpack-basic/build
        
        echo "=== Verifying GPG signatures and checksums ==="
        
        echo "✅ GPG signature verification completed successfully"
        
        # Test individual signature verification for debugging
        echo "=== Manual signature verification ==="
        for package in *.tar.gz *.deb *.rpm *.zip *.dmg; do
          if [[ -f "$package" && -f "$package.sig" ]]; then
            echo "Verifying $package..."
            if gpg --verify "$package.sig" "$package" 2>/dev/null; then
              echo "✅ $package signature valid"
            else
              echo "❌ $package signature invalid"
              exit 1
            fi
          fi
        done

    - name: Test Package Installation and Usage
      shell: bash
      run: |
        cd examples/cpack-basic/build
        
        echo "=== Testing package installation ==="
        
        # Extract Runtime package to test location
        mkdir -p test-runtime
        cd test-runtime
        tar -xzf ../MyLibrary-*-Runtime.tar.gz
        
        # Verify runtime files are present
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          libext="dll"
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          libext="dylib"
        else
          libext="so"
        fi
        
        # Find the shared library
        if find . -name "*cpack_lib*.$libext*" | grep -q .; then
          echo "✅ Runtime library found"
        else
          echo "❌ Runtime library not found"
          find . -type f
          exit 1
        fi
        
        cd ..
        
        # Extract Development package
        mkdir -p test-dev
        cd test-dev
        tar -xzf ../MyLibrary-*-Development.tar.gz
        
        # Verify development files
        if find . -name "*.h" | grep -q .; then
          echo "✅ Development headers found"
        else
          echo "❌ Development headers not found"
          exit 1
        fi
        
        if find . -name "*Config.cmake" -o -name "*config.cmake" | grep -q .; then
          echo "✅ CMake config files found"
        else
          echo "❌ CMake config files not found"
          find . -name "*.cmake" | head -10
          exit 1
        fi
        
        cd ..
        
        # Extract Tools package
        mkdir -p test-tools
        cd test-tools
        tar -xzf ../MyLibrary-*-TOOLS.tar.gz
        
        # Test the tool executable
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          if find . -name "mytool.exe" | grep -q .; then
            echo "✅ Tool executable found"
            # Note: We don't try to run it due to potential DLL dependency issues
          else
            echo "❌ Tool executable not found"
            exit 1
          fi
        else
          if find . -name "mytool" | grep -q .; then
            tool_path=$(find . -name "mytool" | head -n 1)
            echo "✅ Tool executable found at: $tool_path"
            
            # Make executable and test basic functionality
            chmod +x "$tool_path"
            if "$tool_path" --version; then
              echo "✅ Tool executable runs successfully"
            else
              echo "⚠ Tool executable found but failed to run (may need runtime libraries)"
            fi
          else
            echo "❌ Tool executable not found"
            exit 1
          fi
        fi

    - name: Upload CPack Artifacts with GPG Signatures
      uses: actions/upload-artifact@v4
      if: matrix.build_type == 'Release'
      with:
        name: cpack-packages-signed-${{ matrix.os }}
        path: |
          examples/cpack-basic/build/*.tar.gz
          examples/cpack-basic/build/*.zip
          examples/cpack-basic/build/*.deb
          examples/cpack-basic/build/*.rpm
          examples/cpack-basic/build/*.dmg
          examples/cpack-basic/build/*.sig
          examples/cpack-basic/build/*.sha256
          examples/cpack-basic/build/*.sha512
          examples/cpack-basic/build/verify.sh
        retention-days: 7

  cpack-components:
    name: CPack Components Integration Test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4

    - name: Install packaging tools
      run: |
        sudo apt-get update
        sudo apt-get install -y rpm dpkg-dev

    - name: Test Existing Components Example with CPack
      run: |
        cd examples/components
        mkdir build && cd build
        
        # Configure the existing components example
        cmake .. -DCMAKE_INSTALL_PREFIX=./install
        
        # Build
        cmake --build .
        
        # Test installation
        cmake --install .
        
        echo "=== Components example already has export_cpack(), skipping addition ==="
        echo "The components example already includes export_cpack() configuration"
        
        # Generate packages
        cpack --verbose
        
        echo "=== Generated packages from existing components example ==="
        ls -la *.tar.gz *.deb 2>/dev/null || echo "Packages not generated as expected"
        
        # Verify component-based packages were created with new naming scheme
        if ls MediaLibrary-*-CORE.tar.gz 1> /dev/null 2>&1; then
          echo "✅ Components example CPack integration successful"
          
          # Check component contents
          echo "=== Core component group (contains both runtime and development) ==="
          tar -tzf MediaLibrary-*-CORE.tar.gz
          
          echo "=== Tools component group (contains both runtime and development) ==="
          tar -tzf MediaLibrary-*-TOOLS.tar.gz
        else
          echo "⚠ Component packages not generated (may be expected based on configuration)"
          echo "Checking what packages were actually generated:"
          ls -la MediaLibrary-*.tar.gz 2>/dev/null || echo "No MediaLibrary packages found"
        fi

  cpack-cross-platform:
    name: CPack Cross-Platform Package and Signature Validation
    runs-on: ubuntu-latest
    needs: [cpack-basic]
    
    steps:
    - uses: actions/checkout@v4

    - name: Install GPG for signature verification
      run: |
        sudo apt-get update
        sudo apt-get install -y gnupg2

    - name: Download All Platform Artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts

    - name: Analyze Cross-Platform Package and Signature Consistency
      run: |
        echo "=== Cross-Platform Package and Signature Analysis ==="
        
        cd artifacts
        
        for platform in */; do
          echo "=== Platform: $platform ==="
          cd "$platform"
          
          echo "Generated packages:"
          ls -la *.tar.gz *.zip *.deb *.rpm *.dmg 2>/dev/null || echo "No packages found"
          
          echo "Generated signatures:"
          ls -la *.sig 2>/dev/null || echo "No signatures found"
          
          echo "Generated checksums:"
          ls -la *.sha256 *.sha512 2>/dev/null || echo "No checksums found"
          
          echo "Verification script:"
          ls -la verify.sh 2>/dev/null || echo "No verification script found"
          
          # Check for consistent component separation across platforms
          if ls *-Runtime.tar.gz 1> /dev/null 2>&1; then
            echo "✅ Runtime component package found"
          else
            echo "❌ Runtime component package missing"
          fi
          
          if ls *-Development.tar.gz 1> /dev/null 2>&1; then
            echo "✅ Development component package found"
          else
            echo "❌ Development component package missing"
          fi
          
          if ls *-TOOLS.tar.gz 1> /dev/null 2>&1; then
            echo "✅ Tools component package found"
          else
            echo "❌ Tools component package missing"
          fi
          
          # Check for signatures matching packages
          echo "=== Signature coverage analysis ==="
          for pkg in *.tar.gz *.zip *.deb *.rpm *.dmg; do
            if [[ -f "$pkg" ]]; then
              if [[ -f "$pkg.sig" ]]; then
                echo "✅ $pkg has signature"
              else
                echo "❌ $pkg missing signature"
              fi
            fi
          done
          
          cd ..
        done
        
        echo "✅ Cross-platform package and signature validation completed"

  cpack-regression:
    name: CPack Regression Tests
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4

    - name: Test CPack with Different Component Configurations
      run: |
        echo "=== CPack Regression Tests ==="
        
        cd tests/cpack-regression
        
        # Run all regression tests using the new test structure
        bash run-all-tests.sh
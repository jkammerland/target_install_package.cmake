# Generated GPG package signing script
# This script is executed by CPack after package generation

cmake_minimum_required(VERSION 3.23)

# Signing configuration (substituted by CMake configure_file)
set(GPG_EXECUTABLE "@GPG_EXECUTABLE@")
set(SIGNING_KEY "@ARG_SIGNING_KEY@")
set(PASSPHRASE_FILE "@ARG_PASSPHRASE_FILE@")
set(SIGNING_METHOD "@ARG_SIGNING_METHOD@")
set(KEYSERVER "@ARG_KEYSERVER@")
set(GENERATE_CHECKSUMS "@ARG_GENERATE_CHECKSUMS@")
set(GENERATE_VERIFICATION_SCRIPT "@ARG_GENERATE_VERIFICATION_SCRIPT@")
set(PACKAGE_NAME "@ARG_PACKAGE_NAME@")
set(PACKAGE_VERSION "@ARG_PACKAGE_VERSION@")
set(PACKAGE_CONTACT "@ARG_PACKAGE_CONTACT@")

# CPack provides these variables during post-build script execution
# CPACK_PACKAGE_DIRECTORY - where packages are generated
# CPACK_PACKAGE_FILES - list of generated package files

message(STATUS "[GPG Signing] Starting package signing process...")
message(STATUS "[GPG Signing] Package directory: ${CPACK_PACKAGE_DIRECTORY}")

# Find all generated package files if CPACK_PACKAGE_FILES not available
if(NOT CPACK_PACKAGE_FILES)
  file(GLOB PACKAGE_FILES 
    "${CPACK_PACKAGE_DIRECTORY}/*.tar.gz"
    "${CPACK_PACKAGE_DIRECTORY}/*.tar.xz" 
    "${CPACK_PACKAGE_DIRECTORY}/*.tgz"
    "${CPACK_PACKAGE_DIRECTORY}/*.zip"
    "${CPACK_PACKAGE_DIRECTORY}/*.deb"
    "${CPACK_PACKAGE_DIRECTORY}/*.rpm"
    "${CPACK_PACKAGE_DIRECTORY}/*.msi"
    "${CPACK_PACKAGE_DIRECTORY}/*.dmg"
    "${CPACK_PACKAGE_DIRECTORY}/*.pkg"
  )
else()
  set(PACKAGE_FILES ${CPACK_PACKAGE_FILES})
endif()

if(NOT PACKAGE_FILES)
  message(WARNING "[GPG Signing] No package files found to sign")
  return()
endif()

list(LENGTH PACKAGE_FILES package_count)
message(STATUS "[GPG Signing] Found ${package_count} package(s) to sign")

# Sign each package file
foreach(package_file ${PACKAGE_FILES})
  get_filename_component(package_name ${package_file} NAME)
  message(STATUS "[GPG Signing] Signing ${package_name}...")
  
  # Create detached signature
  if(SIGNING_METHOD STREQUAL "detached" OR SIGNING_METHOD STREQUAL "both")
    set(signature_file "${package_file}.sig")
    
    # Prepare GPG command
    set(gpg_cmd ${GPG_EXECUTABLE} --batch --yes --detach-sign --armor)
    
    # Add passphrase handling if file provided
    if(PASSPHRASE_FILE AND EXISTS "${PASSPHRASE_FILE}")
      list(APPEND gpg_cmd --pinentry-mode loopback --passphrase-file "${PASSPHRASE_FILE}")
    endif()
    
    # Add signing key and output file
    list(APPEND gpg_cmd --default-key "${SIGNING_KEY}" --output "${signature_file}" "${package_file}")
    
    # Execute signing
    execute_process(
      COMMAND ${gpg_cmd}
      RESULT_VARIABLE sign_result
      OUTPUT_VARIABLE sign_output
      ERROR_VARIABLE sign_error
    )
    
    if(NOT sign_result EQUAL 0)
      message(FATAL_ERROR "[GPG Signing] Failed to sign ${package_name}: ${sign_error}")
    endif()
    
    message(STATUS "[GPG Signing] Created signature: ${package_name}.sig")
  endif()
  
  # Generate checksums if requested
  if(GENERATE_CHECKSUMS)
    # Generate SHA256
    execute_process(
      COMMAND ${CMAKE_COMMAND} -E sha256sum "${package_file}"
      OUTPUT_VARIABLE sha256_output
      RESULT_VARIABLE sha256_result
    )
    
    if(sha256_result EQUAL 0)
      file(WRITE "${package_file}.sha256" "${sha256_output}")
      string(REGEX MATCH "^[a-f0-9]+" sha256_hash "${sha256_output}")
      message(STATUS "[GPG Signing] Created SHA256: ${package_name}.sha256 (${sha256_hash})")
    endif()
    
    # Generate SHA512
    execute_process(
      COMMAND ${CMAKE_COMMAND} -E sha512sum "${package_file}"
      OUTPUT_VARIABLE sha512_output
      RESULT_VARIABLE sha512_result  
    )
    
    if(sha512_result EQUAL 0)
      file(WRITE "${package_file}.sha512" "${sha512_output}")
      string(REGEX MATCH "^[a-f0-9]+" sha512_hash "${sha512_output}")
      message(STATUS "[GPG Signing] Created SHA512: ${package_name}.sha512 (${sha512_hash})")
    endif()
  endif()
endforeach()

# Copy signatures and checksums to be alongside the packages  
# Packages are in CPACK_PACKAGE_DIRECTORY, but signatures may be in subdirectories
message(STATUS "[GPG Signing] Ensuring signatures are in package directory...")

foreach(package_file ${PACKAGE_FILES})
  get_filename_component(package_name ${package_file} NAME)
  
  # Target location is the same directory as the package (CPACK_PACKAGE_DIRECTORY)
  set(target_signature "${CPACK_PACKAGE_DIRECTORY}/${package_name}.sig")
  set(target_sha256 "${CPACK_PACKAGE_DIRECTORY}/${package_name}.sha256")
  set(target_sha512 "${CPACK_PACKAGE_DIRECTORY}/${package_name}.sha512")
  
  # Always copy to ensure fresh signatures on rebuilds
  if(EXISTS "${package_file}.sig")
    file(COPY_FILE "${package_file}.sig" "${target_signature}")
    message(STATUS "[GPG Signing] Copied ${package_name}.sig to package directory")
  endif()
  
  if(GENERATE_CHECKSUMS)
    if(EXISTS "${package_file}.sha256")
      file(COPY_FILE "${package_file}.sha256" "${target_sha256}")
      message(STATUS "[GPG Signing] Copied ${package_name}.sha256 to package directory")
    endif()
    
    if(EXISTS "${package_file}.sha512")
      file(COPY_FILE "${package_file}.sha512" "${target_sha512}")  
      message(STATUS "[GPG Signing] Copied ${package_name}.sha512 to package directory")
    endif()
  endif()
endforeach()

# Generate verification script if requested
if(GENERATE_VERIFICATION_SCRIPT)
  message(STATUS "[GPG Signing] Generating verification script...")
  
  # Generate script in build directory alongside packages and signatures
  set(verify_script "${CPACK_PACKAGE_DIRECTORY}/verify.sh")
  
  # Use template to generate the verification script
  configure_file(
    "@CMAKE_CURRENT_FUNCTION_LIST_DIR@/cmake/verify_template.sh.in"
    "${verify_script}"
    @ONLY
  )
  
  # Make script executable
  execute_process(COMMAND chmod +x "${verify_script}")
  
  message(STATUS "[GPG Signing] Created verification script: verify.sh")
endif()

message(STATUS "[GPG Signing] Package signing completed successfully!")
#!/bin/bash
# Enhanced Package Verification Script for @PACKAGE_NAME@ v@PACKAGE_VERSION@
# Generated by target_install_package.cmake
# Usage: verify.sh [OPTIONS]

# Removed set -e to handle verification errors properly

# Configuration from build
DEFAULT_SIGNING_KEY="@SIGNING_KEY@"
DEFAULT_KEYSERVER="@KEYSERVER@"
GENERATE_CHECKSUMS="@GENERATE_CHECKSUMS@"

# Default values
PACKAGE_TYPES="rpm,deb,tar.gz,zip,pkg,dmg,msi"
DIRECTORY="."
MIN_PACKAGES=1
SIGNING_KEY="$DEFAULT_SIGNING_KEY"
KEYSERVER="$DEFAULT_KEYSERVER"
VERBOSE=false

# Package type extensions mapping
declare -A EXTENSIONS
EXTENSIONS[rpm]="*.rpm"
EXTENSIONS[deb]="*.deb"
EXTENSIONS[tar.gz]="*.tar.gz *.tgz"
EXTENSIONS[zip]="*.zip"
EXTENSIONS[pkg]="*.pkg"
EXTENSIONS[dmg]="*.dmg"  
EXTENSIONS[msi]="*.msi"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Verify GPG signatures and checksums for packages.

OPTIONS:
    --package-types TYPES    Comma-separated list: rpm,deb,tar.gz,zip,pkg,dmg,msi (default: all)
    --directory DIR          Directory to search for packages (default: current)
    --min-packages N         Minimum packages that must verify successfully (default: 1)
    --key-id KEYID          Expected GPG key ID for validation (default: from build)
    --keyserver URL         Keyserver for key import (default: from build)
    --verbose               Enable verbose output
    --help                  Show this help message

EXAMPLES:
    $0                                           # Verify all packages in current directory
    $0 --package-types rpm,deb                  # Verify only RPM and DEB packages
    $0 --directory ../build --min-packages 3    # Require at least 3 packages
    $0 --verbose                                 # Show detailed verification output

EXIT CODES:
    0    Success: minimum packages verified
    1    Failure: below minimum threshold or verification errors
    2    Usage error: invalid arguments
EOF
}

log() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "$@" >&2
    fi
}

error() {
    echo -e "${RED}ERROR: $*${NC}" >&2
}

success() {
    echo -e "${GREEN}✓ $*${NC}"
}

warning() {
    echo -e "${YELLOW}⚠ $*${NC}" >&2
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --package-types)
            PACKAGE_TYPES="$2"
            shift 2
            ;;
        --directory)
            DIRECTORY="$2"
            shift 2
            ;;
        --min-packages)
            MIN_PACKAGES="$2"
            shift 2
            ;;
        --key-id)
            SIGNING_KEY="$2"
            shift 2
            ;;
        --keyserver)
            KEYSERVER="$2"
            shift 2
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --help)
            usage
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            usage
            exit 2
            ;;
    esac
done

# Validate arguments
if [[ ! -d "$DIRECTORY" ]]; then
    error "Directory does not exist: $DIRECTORY"
    exit 2
fi

if [[ ! "$MIN_PACKAGES" =~ ^[0-9]+$ ]] || [[ "$MIN_PACKAGES" -lt 1 ]]; then
    error "Invalid minimum packages count: $MIN_PACKAGES"
    exit 2
fi

log "Configuration:"
log "  Package types: $PACKAGE_TYPES"
log "  Directory: $DIRECTORY"
log "  Min packages: $MIN_PACKAGES"
log "  Signing key: $SIGNING_KEY"
log "  Keyserver: $KEYSERVER"

# Find packages
find_packages() {
    local found_packages=()
    
    for type in ${PACKAGE_TYPES//,/ }; do
        if [[ ${EXTENSIONS[$type]} ]]; then
            log "Searching for $type packages..."
            # Split patterns by space and process each one
            read -ra patterns <<< "${EXTENSIONS[$type]}"
            for pattern in "${patterns[@]}"; do
                while IFS= read -r -d '' file; do
                    found_packages+=("$file")
                done < <(find "$DIRECTORY" -maxdepth 1 -name "$pattern" -type f -print0 2>/dev/null)
            done
        else
            warning "Unknown package type: $type"
        fi
    done
    
    printf '%s\n' "${found_packages[@]}" | sort -u
}

# Import GPG key
import_key() {
    if [[ -n "$SIGNING_KEY" ]] && [[ -n "$KEYSERVER" ]]; then
        log "Importing GPG key: $SIGNING_KEY"
        if ! gpg --keyserver "$KEYSERVER" --recv-keys "$SIGNING_KEY" 2>/dev/null; then
            log "Key import failed (key may already exist)"
        fi
    fi
}

# Verify a single package
verify_package() {
    local package="$1"
    local basename=$(basename "$package")
    local verified=false
    
    log "Verifying: $basename"
    
    # Check if signature file exists
    if [[ ! -f "$package.sig" ]]; then
        warning "$basename.sig not found"
        return 1
    fi
    
    # Verify GPG signature
    if gpg --verify "$package.sig" "$package" 2>/dev/null; then
        log "GPG signature verified for $basename"
        verified=true
    else
        error "GPG signature verification failed for $basename"
        return 1
    fi
    
    # Verify checksums if available
    if [[ "$GENERATE_CHECKSUMS" == "TRUE" ]]; then
        if [[ -f "$package.sha256" ]]; then
            if (cd "$(dirname "$package")" && sha256sum -c "$(basename "$package.sha256")") &>/dev/null; then
                log "SHA256 checksum verified for $basename"
            else
                error "SHA256 checksum verification failed for $basename"
                return 1
            fi
        fi
        
        if [[ -f "$package.sha512" ]]; then
            if (cd "$(dirname "$package")" && sha512sum -c "$(basename "$package.sha512")") &>/dev/null; then
                log "SHA512 checksum verified for $basename"
            else
                error "SHA512 checksum verification failed for $basename"
                return 1
            fi
        fi
    fi
    
    if [[ "$verified" == "true" ]]; then
        success "$(basename "$package") verified successfully"
        return 0
    fi
    
    return 1
}

# Main verification function
main() {
    local packages
    local verified_count=0
    local total_count=0
    
    # Import key first
    import_key
    
    # Find packages
    mapfile -t packages < <(find_packages)
    total_count=${#packages[@]}
    
    if [[ $total_count -eq 0 ]]; then
        error "No packages found in $DIRECTORY matching types: $PACKAGE_TYPES"
        exit 1
    fi
    
    log "Found $total_count package(s) to verify"
    
    # Verify each package
    for package in "${packages[@]}"; do
        if verify_package "$package"; then
            ((verified_count++))
        fi
    done
    
    # Report results
    echo ""
    echo "Verification Results:"
    echo "  Total packages: $total_count"
    echo "  Successfully verified: $verified_count"
    echo "  Required minimum: $MIN_PACKAGES"
    
    if [[ $verified_count -ge $MIN_PACKAGES ]]; then
        success "Verification completed successfully ($verified_count/$total_count packages verified)"
        exit 0
    else
        error "Verification failed: only $verified_count/$total_count packages verified (minimum: $MIN_PACKAGES)"
        exit 1
    fi
}

# Run main function
main "$@"
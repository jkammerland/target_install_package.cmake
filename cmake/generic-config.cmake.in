@PACKAGE_INIT@

function(find_component_dependencies package_name component_deps_string)
    if(NOT ${package_name}_FIND_COMPONENTS OR NOT component_deps_string)
        return()
    endif()
    
    foreach(requested_comp IN LISTS ${package_name}_FIND_COMPONENTS)
        # Use regex to find this component's dependencies
        if(component_deps_string MATCHES "(^|;)${requested_comp}:([^;]*)")
            string(REPLACE " " ";" deps_list "${CMAKE_MATCH_2}")
            foreach(dep IN LISTS deps_list)
                string(STRIP "${dep}" dep)
                if(dep)
                    find_dependency(${dep})
                endif()
            endforeach()
        endif()
    endforeach()
endfunction()


if(NOT COMMAND find_dependency)
  include(CMakeFindDependencyMacro)
endif()

# Component-dependent dependencies
find_component_dependencies(@ARG_EXPORT_NAME@ "@PACKAGE_COMPONENT_DEPENDENCIES_CONTENT@")

# Package global dependencies (always loaded regardless of components)
@PACKAGE_PUBLIC_DEPENDENCIES_CONTENT@

# Include additional CMake files on find_package
@PACKAGE_INCLUDE_ON_FIND_PACKAGE@

# Map consumer build configurations to installed ones before importing targets.
# This prevents CMake from falling back to the first available config (often Debug)
# when the consumer builds with RelWithDebInfo or MinSizeRel. Keep Debug mapped
# to Debug and only map the "middle" configs to Release by default. Downstream
# projects can override these if they have a different policy.
if(NOT DEFINED CMAKE_MAP_IMPORTED_CONFIG_RELWITHDEBINFO)
  set(CMAKE_MAP_IMPORTED_CONFIG_RELWITHDEBINFO Release)
endif()
if(NOT DEFINED CMAKE_MAP_IMPORTED_CONFIG_MINSIZEREL)
  set(CMAKE_MAP_IMPORTED_CONFIG_MINSIZEREL Release)
endif()

# CMake's generated export file automatically handles configuration-specific includes
include("${CMAKE_CURRENT_LIST_DIR}/@ARG_EXPORT_NAME@.cmake")

check_required_components(@ARG_EXPORT_NAME@)
